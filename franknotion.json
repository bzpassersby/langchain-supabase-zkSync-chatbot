[{"pageContent":"# Basic Concepts Priority operations Transactions # Priority operations Deposit: Moves funds from the Ethereum network to the designated account in the zkSync network. If the recipient account does not exist yet on the zkSync network, it will be created and a numeric ID will be assigned to the provided address. FullExit: Withdraws funds from the zkSync network to the Ethereum network without interacting with the zkSync server. This operation can be used as an emergency exit in case of detected censorship from the zkSync server node, or to withdraw funds in the situation where the signing key for an account in zkSync network cannot be set (e.g. if the address corresponds to a smart contract). # Transactions ChangePubKey: Sets (or changes) the signing key associated with the account. Without a signing key set, no operation (except for priority operations) can be authorized by the corresponding account. Transfer: Transfers funds from one zkSync account to another zkSync account. If the recipient account does not exist yet on the zkSync network, it will be created and a numeric ID will be assigned to the provided address. Swap: Atomically swaps funds between two existing zkSync accounts. Withdraw: Withdraws funds from the zkSync network to the Ethereum network. ForcedExit: Withdraws funds from the \"target\" L2 account that doesn't have a signing key set, to the same \"target\" address on the Ethereum network. This operation can be used to withdraw funds in the situation where the signing key for account in zkSync network cannot be set (e.g. if address corresponds to a smart contract). MintNFT: Mints an NFT based on provided content hash to the provided \"recipient\". WithdrawNFT: Withdraw an NFT from the zkSync network to the Ethereum network. # Creating an account # Setting the signing key If a transfer to some address is valid in Ethereum, it's also valid in zkSync. Not every address can have a private key (e.g. some smart contracts). Transfers to a user's account may happen before they've been interested in zkSync. zkSync signature of the transaction data, so that it won't be possible to mutate transaction contents. Ethereum signature proving account ownership. # Example of network validation # Transferring funds # Fees Amount of data that will be sent to the Ethereum network. Current gas price. Cost of computational resources to generate a proof for a block with the transaction. # Withdrawing funds","metadata":{"source":"https://docs.zksync.io/dev/payments/basic","title":"# Basic Concepts","contentLength":395}},{"pageContent":"# Sending Transactions Prepare the transaction data. Encode the transaction data into a byte sequence. Create a zkSync signature for these bytes with the zkSync private key. Either generate an Ethereum signature for transaction description (see details below) or provide an EIP-1271 signature. Send the transaction via corresponding JSON RPC method. Transfer to the recipient in token FOO with fee set to 0. Transfer to the own account in token BAR (the token you want to pay the fee with) with amount set to 0, and fee set enough to cover two transfers. # Ethereum signature for batch # 2-Factor Authentication","metadata":{"source":"https://docs.zksync.io/dev/payments/sending_transactions","title":"# Sending Transactions","contentLength":100}},{"pageContent":"# Smart contracts # Porting Smart Contracts # UI Interaction For read requests: any web3-compliant framework in any language will work out of the box, with additional optional zkSync L2 specific functionality. For write requests (sending transactions): due to fundamental differences between L1 and L2, you will have to write some additional code (for example, zkSync supports paying fees in any token, so sending a transaction will involve choosing a token to pay fees). # Submitting Transactions # Deployment","metadata":{"source":"https://docs.zksync.io/dev/contracts","title":"# Smart contracts","contentLength":75}}]